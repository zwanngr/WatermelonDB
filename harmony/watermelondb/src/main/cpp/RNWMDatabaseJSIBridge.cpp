/**
 * This code was generated by "react-native codegen-lib-harmony"
 */
#include "RNOH/ArkTSTurboModule.h"
#include "RNOH/RNInstance.h"
#include "RNWMDatabaseJSIBridge.h"
#include <string>
#include <map>
#include <memory>
#include <database/rdb/relational_store.h>
#include <database/rdb/oh_predicates.h>
#include <database/rdb/oh_values_bucket.h>
#include <database/rdb/oh_cursor.h>
#include <database/rdb/relational_store_error_code.h>
#include <database/udmf/udmf.h>
#include <database/rdb/oh_rdb_transaction.h>
#include <database/data/oh_data_values.h>

using namespace rnoh;
using namespace facebook;

static OH_Rdb_Store *globalStore = nullptr;
static std::mutex storeMutex;
static bool isDatabaseInitialized = false;

static jsi::Value hostFunction_MyTMTurboModule_install(jsi::Runtime &rt, react::TurboModule &turboModule,
                                                       const jsi::Value *args, size_t count)
{
    auto self = static_cast<RNWMDatabaseJSIBridge *>(&turboModule);
    self->JSIInstall(rt);
    std::string myString = "aaabbb";
    DLOG(ERROR) << "123456789 正在调用 myInstall 函数";
    return jsi::String::createFromUtf8(rt, myString);
}

RNWMDatabaseJSIBridge::RNWMDatabaseJSIBridge(const RNWMDatabaseJSIBridge::Context ctx, const std::string name) : WMDatabaseJSIBridge(ctx, name)
{
    methodMap_["myInstall"] = MethodMetadata{0, hostFunction_MyTMTurboModule_install};
}

void RNWMDatabaseJSIBridge::JSIInstall(facebook::jsi::Runtime &rt)
{
    DLOG(ERROR) << "123456789 JSI初始化开始";

    // 1. 获取全局对象
    auto globalObject = rt.global();

    // 2. 创建nativeWatermelonCreateAdapter函数
    auto createAdapterFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "nativeWatermelonCreateAdapter"),
        2, // 参数数量：dbPath, usesExclusiveLocking
        [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
        {
            if (count < 2)
            {
                throw jsi::JSError(rt, "nativeWatermelonCreateAdapter requires 2 arguments");
            }

            std::string dbPath = args[0].getString(rt).utf8(rt);
            bool usesExclusiveLocking = args[1].getBool();

            // 创建适配器对象
            jsi::Object adapter(rt);

            // 1. initialize方法
            auto initializeFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "initialize"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "initialize requires 2 arguments");
                    }

                    // 提取参数
                    std::string dbName = args[0].getString(rt).utf8(rt);
                    int expectedVersion = (int)args[1].getNumber();

                    DLOG(ERROR) << "123456789 初始化调用 - 数据库名: " << dbName << ", 版本: " << expectedVersion;

                    std::lock_guard<std::mutex> lock(storeMutex);

                    // 如果已经初始化过，直接返回成功
                    if (isDatabaseInitialized && globalStore != nullptr)
                    {
                        DLOG(ERROR) << "123456789 数据库已经初始化，直接返回";

                        jsi::Object response(rt);
                        response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                        response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Database already initialized"));
                        response.setProperty(rt, "databaseName", jsi::String::createFromUtf8(rt, dbName));
                        response.setProperty(rt, "version", jsi::Value(expectedVersion));
                        return response;
                    }

                    int errCode = 0;

                    // 创建配置对象
                    OH_Rdb_ConfigV2 *config = OH_Rdb_CreateConfig();
                    if (config == NULL)
                    {
                        throw jsi::JSError(rt, "Failed to create database config");
                    }

                    // 设置数据库文件目录
                    OH_Rdb_SetDatabaseDir(config, "/data/storage/el2/database");

                    // 使用传入的数据库名称
                    std::string storeName = dbName + ".db";
                    OH_Rdb_SetStoreName(config, storeName.c_str());

                    // 设置应用包名和模块名（需要根据实际应用修改）
                    OH_Rdb_SetBundleName(config, "com.harmony.watermelondb.demo");
                    OH_Rdb_SetModuleName(config, "entry");

                    // 设置安全级别和加密
                    OH_Rdb_SetSecurityLevel(config, OH_Rdb_SecurityLevel::S1);
                    OH_Rdb_SetEncrypted(config, false);

                    // 设置区域（area）和数据库类型（dbType）
                    OH_Rdb_SetArea(config, RDB_SECURITY_AREA_EL2);
                    OH_Rdb_SetDbType(config, 1);
                    OH_Rdb_SetPersistent(config, 1);
                    OH_Rdb_SetReadOnly(config, 0);

                    // 获取数据库操作实例
                    globalStore = OH_Rdb_CreateOrOpen(config, &errCode);
                    OH_Rdb_DestroyConfig(config); // 配置对象可以销毁了

                    if (globalStore == NULL || errCode != RDB_OK)
                    {
                        DLOG(ERROR) << "123456789 数据库初始化失败 - 错误代码: " << errCode;
                        throw jsi::JSError(rt, "Database initialization failed with error code: " + std::to_string(errCode));
                    }

                    isDatabaseInitialized = true;
                    DLOG(ERROR) << "123456789 数据库初始化成功 - store: " << globalStore;
                    //-------------创建测试表并插入数据-----------------------------
                    // const char *createTableSQL = "CREATE TABLE IF NOT EXISTS movies (id TEXT PRIMARY KEY, title TEXT, year INTEGER, genre TEXT)";
                    // errCode = OH_Rdb_ExecuteV2(globalStore, createTableSQL, nullptr, nullptr);
                    // if (errCode != RDB_OK)
                    // {
                    //     DLOG(ERROR) << "123456789 创建表失败: " << errCode;
                    // }
                    // else
                    // {
                    //     DLOG(ERROR) << "123456789 表创建成功";

                    //     // 插入测试数据
                    //     const char *insertSQL = "INSERT OR REPLACE INTO movies (id, title, year, genre) VALUES ('6', '测试6', 33333, 'cccccc')";

                    //     errCode = OH_Rdb_ExecuteV2(globalStore, insertSQL, nullptr, nullptr);
                    //     DLOG(ERROR) << "123456789 插入数据的结果: " << errCode;
                    // }
                    //----------------------删除数据--------------------------
                    // const char *dropTableSQL = "DROP TABLE IF EXISTS movies";
                    // errCode = OH_Rdb_ExecuteV2(globalStore, dropTableSQL, nullptr, nullptr);
                    // DLOG(ERROR) << "123456789 删除表结果: " << errCode;
                    //------------------------------------------------
                    // 创建响应对象
                    jsi::Object response(rt);
                    response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                    response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Database initialized successfully"));
                    response.setProperty(rt, "databaseName", jsi::String::createFromUtf8(rt, dbName));
                    response.setProperty(rt, "version", jsi::Value(expectedVersion));

                    DLOG(ERROR) << "123456789 初始化完成";
                    return response;
                });

            // 2. setUpWithSchema方法
            auto setUpWithSchemaFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setUpWithSchema"),
                3,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 3)
                    {
                        throw jsi::JSError(rt, "setUpWithSchema requires 3 arguments");
                    }

                    std::string dbName = args[0].getString(rt).utf8(rt);
                    std::string schema = args[1].getString(rt).utf8(rt);
                    int schemaVersion = (int)args[2].getNumber();

                    DLOG(ERROR) << "123456789 设置Schema调用 - 数据库名: " << dbName
                                << ", schema版本: " << schemaVersion;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 解析schema并创建表
                        DLOG(ERROR) << "123456789 Schema设置 - 数据库: " << dbName;

                        // 简单的JSON解析器 - 解析表定义
                        std::vector<std::string> tableNames;
                        std::vector<std::string> createTableSQLs;

                        // 查找表定义
                        size_t pos = 0;
                        while ((pos = schema.find("\"name\":", pos)) != std::string::npos)
                        {
                            // 找到表名
                            size_t nameStart = schema.find('"', pos + 7) + 1;
                            size_t nameEnd = schema.find('"', nameStart);
                            if (nameStart != std::string::npos && nameEnd != std::string::npos)
                            {
                                std::string tableName = schema.substr(nameStart, nameEnd - nameStart);
                                tableNames.push_back(tableName);
                                DLOG(ERROR) << "123456789 发现表: " << tableName;
                            }
                            pos = nameEnd + 1;
                        }

                        // 为每个表创建SQL语句
                        for (const auto &tableName : tableNames)
                        {
                            // 查找表的列定义
                            std::string tablePattern = "\"name\":\"" + tableName + "\"";
                            size_t tablePos = schema.find(tablePattern);
                            if (tablePos != std::string::npos)
                            {
                                // 查找columns数组
                                size_t columnsStart = schema.find("\"columns\":", tablePos);
                                if (columnsStart != std::string::npos)
                                {
                                    columnsStart = schema.find('[', columnsStart);
                                    size_t columnsEnd = schema.find(']', columnsStart);

                                    if (columnsStart != std::string::npos && columnsEnd != std::string::npos)
                                    {
                                        std::string columnsSection = schema.substr(columnsStart, columnsEnd - columnsStart + 1);

                                        // 构建CREATE TABLE语句
                                        std::string createSQL = "CREATE TABLE IF NOT EXISTS " + tableName + " (";
                                        std::vector<std::string> columnDefs;

                                        // 添加id列作为主键
                                        columnDefs.push_back("id TEXT PRIMARY KEY");

                                        // 解析列定义
                                        size_t colPos = 0;
                                        while ((colPos = columnsSection.find("\"name\":", colPos)) != std::string::npos)
                                        {
                                            size_t colNameStart = columnsSection.find('"', colPos + 7) + 1;
                                            size_t colNameEnd = columnsSection.find('"', colNameStart);
                                            if (colNameStart != std::string::npos && colNameEnd != std::string::npos)
                                            {
                                                std::string colName = columnsSection.substr(colNameStart, colNameEnd - colNameStart);

                                                // 查找列类型
                                                size_t typePos = columnsSection.find("\"type\":", colNameEnd);
                                                if (typePos != std::string::npos)
                                                {
                                                    size_t typeStart = columnsSection.find('"', typePos + 7) + 1;
                                                    size_t typeEnd = columnsSection.find('"', typeStart);
                                                    if (typeStart != std::string::npos && typeEnd != std::string::npos)
                                                    {
                                                        std::string colType = columnsSection.substr(typeStart, typeEnd - typeStart);

                                                        // 映射WatermelonDB类型到SQLite类型
                                                        std::string sqlType = "TEXT";
                                                        if (colType == "number" || colType == "boolean")
                                                        {
                                                            sqlType = "INTEGER";
                                                        }

                                                        columnDefs.push_back(colName + " " + sqlType);
                                                        DLOG(ERROR) << "123456789 表 " << tableName << " 列: " << colName << " 类型: " << colType;
                                                    }
                                                }
                                            }
                                            colPos = colNameEnd + 1;
                                        }

                                        // 添加标准WatermelonDB列
                                        columnDefs.push_back("_status TEXT");
                                        columnDefs.push_back("_changed TEXT");

                                        // 完成SQL语句
                                        for (size_t i = 0; i < columnDefs.size(); i++)
                                        {
                                            createSQL += columnDefs[i];
                                            if (i < columnDefs.size() - 1)
                                            {
                                                createSQL += ", ";
                                            }
                                        }
                                        createSQL += ")";

                                        createTableSQLs.push_back(createSQL);
                                        DLOG(ERROR) << "123456789 创建表SQL: " << createSQL;
                                    }
                                }
                            }
                        }

                        // 执行所有CREATE TABLE语句
                        int errCode = 0;
                        for (const auto &sql : createTableSQLs)
                        {
                            DLOG(ERROR) << "123456789 正在执行SQL: " << sql;
                            int result = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                            if (result != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 执行SQL失败: " << sql << ", 错误代码: " << result;
                                throw jsi::JSError(rt, "Failed to create table, SQL: " + sql + ", error code: " + std::to_string(result));
                            }
                        }

                        DLOG(ERROR) << "123456789 Schema设置完成，创建了 " << createTableSQLs.size() << " 个表";

                        jsi::Object response(rt);
                        response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                        response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Schema setup completed"));
                        response.setProperty(rt, "version", jsi::Value(schemaVersion));
                        response.setProperty(rt, "tablesCreated", jsi::Value((int)tableNames.size()));

                        return response;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "setUpWithSchema failed: " + std::string(e.what()));
                    }
                });

            // 3. setUpWithMigrations方法
            auto setUpWithMigrationsFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setUpWithMigrations"),
                4,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 4)
                    {
                        throw jsi::JSError(rt, "setUpWithMigrations requires 4 arguments");
                    }

                    std::string dbName = args[0].getString(rt).utf8(rt);
                    std::string migrationSchema = args[1].getString(rt).utf8(rt);
                    int fromVersion = (int)args[2].getNumber();
                    int toVersion = (int)args[3].getNumber();

                    DLOG(ERROR) << "123456789 迁移设置调用 - 数据库名: " << dbName
                                << ", 从版本: " << fromVersion << ", 到版本: " << toVersion;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for migrations");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 解析迁移schema（JSON格式）
                            // 期望格式: {"migrations": [{"to_version": 2, "sql": "CREATE TABLE..."}, ...]}
                            DLOG(ERROR) << "123456789 迁移schema: " << migrationSchema;

                            // 简单的JSON解析实现
                            if (migrationSchema.empty() || migrationSchema[0] != '{' || migrationSchema[migrationSchema.length() - 1] != '}')
                            {
                                throw std::runtime_error("Invalid migration schema format");
                            }

                            // 查找migrations数组
                            size_t migrationsPos = migrationSchema.find("\"migrations\":");
                            if (migrationsPos == std::string::npos)
                            {
                                throw std::runtime_error("Migration schema missing 'migrations' field");
                            }

                            // 提取migrations数组内容
                            size_t arrayStart = migrationSchema.find('[', migrationsPos);
                            size_t arrayEnd = migrationSchema.find(']', arrayStart);
                            if (arrayStart == std::string::npos || arrayEnd == std::string::npos)
                            {
                                throw std::runtime_error("Invalid migrations array format");
                            }

                            std::string migrationsArray = migrationSchema.substr(arrayStart, arrayEnd - arrayStart + 1);
                            DLOG(ERROR) << "123456789 迁移数组: " << migrationsArray;

                            // 执行从fromVersion到toVersion的迁移
                            for (int version = fromVersion + 1; version <= toVersion; version++)
                            {
                                DLOG(ERROR) << "123456789 执行迁移到版本: " << version;

                                // 在migrations数组中查找对应版本的迁移
                                std::string versionStr = "\"to_version\":" + std::to_string(version);
                                size_t versionPos = migrationsArray.find(versionStr);

                                if (versionPos != std::string::npos)
                                {
                                    // 查找SQL语句
                                    size_t sqlPos = migrationsArray.find("\"sql\":", versionPos);
                                    if (sqlPos != std::string::npos)
                                    {
                                        size_t sqlStart = migrationsArray.find('\"', sqlPos + 6) + 1;
                                        size_t sqlEnd = migrationsArray.find('\"', sqlStart);
                                        if (sqlStart != std::string::npos && sqlEnd != std::string::npos)
                                        {
                                            std::string migrationSql = migrationsArray.substr(sqlStart, sqlEnd - sqlStart);
                                            DLOG(ERROR) << "123456789 执行迁移SQL: " << migrationSql;

                                            // 执行迁移SQL
                                            int result = OH_Rdb_ExecuteV2(globalStore, migrationSql.c_str(), nullptr, nullptr);
                                            if (result != RDB_OK)
                                            {
                                                throw std::runtime_error("Migration to version " + std::to_string(version) + " failed, SQL: " + migrationSql + ", error code: " + std::to_string(result));
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    DLOG(ERROR) << "123456789 未找到版本 " << version << " 的迁移，跳过";
                                }
                            }

                            success = true;
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = e.what();
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for migrations");
                            }

                            jsi::Object response(rt);
                            response.setProperty(rt, "code", jsi::String::createFromUtf8(rt, "ok"));
                            response.setProperty(rt, "message", jsi::String::createFromUtf8(rt, "Migrations completed successfully"));
                            response.setProperty(rt, "fromVersion", jsi::Value(fromVersion));
                            response.setProperty(rt, "toVersion", jsi::Value(toVersion));

                            DLOG(ERROR) << "123456789 迁移完成 - 从版本 " << fromVersion << " 到 " << toVersion;
                            return response;
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "setUpWithMigrations failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "setUpWithMigrations failed: " + std::string(e.what()));
                    }
                });

            // 4. find方法
            auto findFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "find"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "find requires 2 arguments");
                    }

                    // 提取参数
                    std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string id = args[1].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 find调用 - 表: " << tableName << ", ID: " << id;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 构建查询SQL
                        std::string sql = "SELECT * FROM " + tableName + " WHERE id = ?";
                        DLOG(ERROR) << "123456789 正在执行SQL查询: " << sql;

                        // 创建结果对象
                        auto result = jsi::Object(rt);
                        result.setProperty(rt, "id", jsi::String::createFromUtf8(rt, id));
                        result.setProperty(rt, "table", jsi::String::createFromUtf8(rt, tableName));

                        //---------------------测试查询----------------------------------------
                        // OH_Cursor *testCursor = OH_Rdb_ExecuteQueryV2(globalStore, "SELECT * FROM movies", nullptr);
                        // if (testCursor != nullptr)
                        // {
                        //     int rowCount = 0;
                        //     while (testCursor->goToNextRow(testCursor) == RDB_OK)
                        //     {
                        //         rowCount++;
                        //         int64_t idValue;
                        //         char titleValue[256] = {0};
                        //         int64_t yearValue;

                        //         if (testCursor->getInt64(testCursor, 0, &idValue) == RDB_OK)
                        //         {
                        //             testCursor->getText(testCursor, 1, titleValue, sizeof(titleValue));
                        //             testCursor->getInt64(testCursor, 2, &yearValue);
                        //             DLOG(ERROR) << "123456789 数据 - id:" << idValue << " title:" << titleValue << " year:" << yearValue;
                        //         }
                        //     }

                        //     if (rowCount == 0)
                        //     {
                        //         DLOG(ERROR) << "123456789 movies表为空";
                        //     }
                        //     else
                        //     {
                        //         DLOG(ERROR) << "123456789 共找到" << rowCount << "条数据";
                        //     }

                        //     testCursor->destroy(testCursor);
                        // }
                        //-------------------------------------------------------------

                        // 执行查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            result.setProperty(rt, "found", jsi::Value(false));
                            result.setProperty(rt, "error", jsi::String::createFromUtf8(rt, "Query failed"));
                        }
                        else
                        {
                            if (cursor->goToNextRow(cursor) == RDB_OK)
                            {
                                int count = 0;
                                cursor->getColumnCount(cursor, &count);
                                for (int i = 0; i < count; i++)
                                {
                                    // 获取列名
                                    char columnName[256] = {0};
                                    if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK)
                                    {
                                        DLOG(ERROR) << "123456789 第" << i << "列 列名: " << columnName;
                                        OH_ColumnType columnType;
                                        jsi::Value cellValue = jsi::Value::null();

                                        // 获取列类型
                                        if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                        {
                                            switch (columnType)
                                            {
                                            case TYPE_INT64:
                                            {
                                                int64_t intValue;
                                                if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(static_cast<double>(intValue));
                                                }
                                                break;
                                            }
                                            case TYPE_REAL:
                                            {
                                                double doubleValue;
                                                if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(doubleValue);
                                                }
                                                break;
                                            }
                                            case TYPE_TEXT:
                                            {
                                                char textValue[1024] = {0};
                                                if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                                {
                                                    if (strlen(textValue) > 0)
                                                    {
                                                        cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                    }
                                                }
                                                break;
                                            }
                                            case TYPE_BLOB:
                                            {
                                                // BLOB类型暂时返回null
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            case TYPE_NULL:
                                            {
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            default:
                                                DLOG(ERROR) << "123456789 find未知列类型: " << columnType;
                                                break;
                                            }
                                        }

                                        // 设置属性到结果对象
                                        result.setProperty(rt, columnName, cellValue);
                                    }
                                }

                                // 设置固定属性
                                result.setProperty(rt, "found", jsi::Value(true));
                                result.setProperty(rt, "_status", jsi::String::createFromUtf8(rt, "synced"));
                            }
                            else
                            {
                                result.setProperty(rt, "found", jsi::Value(false));
                            }

                            // 清理游标
                            cursor->destroy(cursor);
                        }

                        DLOG(ERROR) << "123456789 find返回结果";
                        return result;
                    }
                    catch (const jsi::JSError &e)
                    {
                        throw e;
                    }
                    catch (const std::exception &e)
                    {
                        auto errorResult = jsi::Object(rt);
                        errorResult.setProperty(rt, "id", jsi::String::createFromUtf8(rt, id));
                        errorResult.setProperty(rt, "table", jsi::String::createFromUtf8(rt, tableName));
                        errorResult.setProperty(rt, "found", jsi::Value(false));
                        errorResult.setProperty(rt, "error", jsi::String::createFromUtf8(rt, e.what()));

                        DLOG(ERROR) << "123456789 find错误: " << e.what();
                        return errorResult;
                    }
                });

            // 5. query方法
            auto queryFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "query"),
                3,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 3)
                    {
                        throw jsi::JSError(rt, "query requires 3 arguments");
                    }

                    std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string sql = args[1].getString(rt).utf8(rt);
                    jsi::Array arguments = args[2].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 query调用 - 表: " << tableName << ", SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 构建完整的SQL查询语句
                        std::string fullSql = "SELECT * FROM " + tableName + " WHERE " + sql;

                        // 执行查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, fullSql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute query: " + fullSql);
                        }

                        // 处理查询结果
                        jsi::Array resultArray = jsi::Array(rt, 0);
                        int rowIndex = 0;

                        // 遍历结果集
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            // 获取列数
                            int columnCount = 0;
                            if (cursor->getColumnCount(cursor, &columnCount) != RDB_OK)
                            {
                                columnCount = 0;
                            }

                            jsi::Object rowObject(rt);

                            // 遍历每一列
                            for (int i = 0; i < columnCount; i++)
                            {
                                // 获取列名
                                char *columnName = nullptr;
                                if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK && columnName != nullptr)
                                {
                                    OH_ColumnType columnType;
                                    jsi::Value cellValue = jsi::Value::null();

                                    // 获取列类型
                                    if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                    {
                                        switch (columnType)
                                        {
                                        case TYPE_INT64:
                                        {
                                            int64_t intValue;
                                            if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(static_cast<double>(intValue));
                                            }
                                            break;
                                        }
                                        case TYPE_REAL:
                                        {
                                            double doubleValue;
                                            if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(doubleValue);
                                            }
                                            break;
                                        }
                                        case TYPE_TEXT:
                                        {
                                            char *textValue = nullptr;
                                            int textLength = 0;
                                            if (cursor->getText(cursor, i, textValue, textLength) == RDB_OK)
                                            {
                                                if (textValue != nullptr)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                            }
                                            break;
                                        }
                                        case TYPE_BLOB:
                                        {
                                            // BLOB类型暂时返回null
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        case TYPE_NULL:
                                        {
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        default:
                                            DLOG(ERROR) << "123456789 query未知列类型: " << columnType;
                                            break;
                                        }
                                    }

                                    rowObject.setProperty(rt, columnName, cellValue);
                                }
                            }

                            resultArray.setValueAtIndex(rt, rowIndex, rowObject);
                            rowIndex++;
                        }

                        // 清理游标
                        cursor->destroy(cursor);

                        DLOG(ERROR) << "123456789 query完成，返回行数: " << rowIndex;
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "query failed: " + std::string(e.what()));
                    }
                });

            // 6. queryAsArray方法
            auto queryAsArrayFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "queryAsArray"),
                3,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 3)
                    {
                        throw jsi::JSError(rt, "queryAsArray requires 3 arguments");
                    }

                    std::string tableName = args[0].getString(rt).utf8(rt);
                    std::string sql = args[1].getString(rt).utf8(rt);
                    jsi::Array arguments = args[2].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 queryAsArray调用 - 表: " << tableName;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 执行查询并获取游标
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute query");
                        }

                        std::vector<jsi::Value> resultRows;
                        int rowIndex = 0;

                        // 遍历结果集
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            int columnCount = 0;
                            if (cursor->getColumnCount(cursor, &columnCount) == RDB_OK)
                            {
                                jsi::Array rowArray = jsi::Array(rt, columnCount);

                                for (int i = 0; i < columnCount; i++)
                                {
                                    OH_ColumnType columnType;
                                    jsi::Value cellValue = jsi::Value::null();

                                    // 获取列类型
                                    if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                    {
                                        switch (columnType)
                                        {
                                        case TYPE_INT64:
                                        {
                                            int64_t intValue;
                                            if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(static_cast<double>(intValue));
                                            }
                                            break;
                                        }
                                        case TYPE_REAL:
                                        {
                                            double doubleValue;
                                            if (cursor->getReal(cursor, i, &doubleValue) == RDB_OK)
                                            {
                                                cellValue = jsi::Value(doubleValue);
                                            }
                                            break;
                                        }
                                        case TYPE_TEXT:
                                        {
                                            char textValue[1024] = {0};
                                            if (cursor->getText(cursor, i, textValue, sizeof(textValue)) == RDB_OK)
                                            {
                                                if (strlen(textValue) > 0)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                            }
                                            break;
                                        }
                                        case TYPE_BLOB:
                                        {
                                            // BLOB类型暂时返回null
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        case TYPE_NULL:
                                        {
                                            cellValue = jsi::Value::null();
                                            break;
                                        }
                                        default:
                                            DLOG(ERROR) << "123456789 queryAsArray未知列类型: " << columnType;
                                            break;
                                        }
                                    }

                                    rowArray.setValueAtIndex(rt, i, cellValue);
                                }

                                resultRows.push_back(std::move(rowArray));
                                rowIndex++;
                            }
                            else
                            {
                                DLOG(ERROR) << "123456789 queryAsArray无法获取列数";
                            }
                        }

                        // 清理游标
                        cursor->destroy(cursor);

                        // 创建结果数组
                        jsi::Array resultArray = jsi::Array(rt, resultRows.size());
                        for (size_t i = 0; i < resultRows.size(); i++)
                        {
                            resultArray.setValueAtIndex(rt, i, resultRows[i]);
                        }

                        DLOG(ERROR) << "123456789 queryAsArray完成，返回行数: " << rowIndex;
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "queryAsArray failed: " + std::string(e.what()));
                    }
                });

            // 7. queryIds方法
            auto queryIdsFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "queryIds"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "queryIds requires 2 arguments");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);

                    jsi::Array arguments = jsi::Array(rt, 0);
                    if (!args[1].isNull() && !args[1].isUndefined())
                    {
                        if (args[1].isObject() && args[1].getObject(rt).isArray(rt))
                        {
                            arguments = args[1].getObject(rt).getArray(rt);
                            DLOG(ERROR) << "123456789 queryIds获取到参数数组，长度: " << arguments.size(rt);
                        }
                        else
                        {
                            DLOG(ERROR) << "123456789 queryIds第二个参数不是数组";
                        }
                    }
                    DLOG(ERROR) << "123456789 queryIds调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }
                        std::vector<jsi::Value> ids;
                        // 执行SQL
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        while (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            OH_Data_Value *cellValue = nullptr;
                            OH_ColumnType columnType;
                            if (cursor->getColumnType(cursor, 0, &columnType) == RDB_OK)
                            {
                                jsi::Value jsValue;

                                switch (columnType)
                                {
                                case TYPE_INT64:
                                {
                                    int64_t intValue;
                                    if (cursor->getInt64(cursor, 0, &intValue) == RDB_OK)
                                    {
                                        jsValue = jsi::Value(static_cast<double>(intValue));
                                        ids.push_back(std::move(jsValue));
                                    }
                                    break;
                                }
                                case TYPE_REAL:
                                {
                                    double doubleValue;
                                    if (cursor->getReal(cursor, 0, &doubleValue) == RDB_OK)
                                    {
                                        jsValue = jsi::Value(doubleValue);
                                        ids.push_back(std::move(jsValue));
                                    }
                                    break;
                                }
                                case TYPE_TEXT:
                                {
                                    char *textValue = nullptr;
                                    int textLength = 0;
                                    if (cursor->getText(cursor, 0, textValue, textLength) == RDB_OK)
                                    {
                                        if (textValue != nullptr)
                                        {
                                            jsValue = jsi::String::createFromUtf8(rt, textValue);
                                            ids.push_back(std::move(jsValue));
                                        }
                                        else
                                        {
                                            jsValue = jsi::Value::null();
                                            ids.push_back(std::move(jsValue));
                                        }
                                    }
                                    break;
                                }
                                case TYPE_NULL:
                                {
                                    jsValue = jsi::Value::null();
                                    ids.push_back(std::move(jsValue));
                                    break;
                                }
                                default:
                                    DLOG(ERROR) << "123456789 queryIds未知类型";
                                    break;
                                }
                            }
                        }
                        cursor->destroy(cursor);

                        jsi::Array resultArray = jsi::Array(rt, ids.size());
                        for (size_t i = 0; i < ids.size(); i++)
                        {
                            resultArray.setValueAtIndex(rt, i, ids[i]);
                        }

                        DLOG(ERROR) << "123456789 queryIds完成";
                        return resultArray;
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "queryIds failed: " + std::string(e.what()));
                    }
                });

            // 8. unsafeQueryRaw方法
            auto unsafeQueryRawFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeQueryRaw"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "unsafeQueryRaw requires 2 arguments");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);
                    jsi::Array arguments = args[1].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 unsafeQueryRaw调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 判断SQL类型（查询 vs 非查询）
                        bool isQuery = false;
                        std::string upperSql = sql;
                        std::transform(upperSql.begin(), upperSql.end(), upperSql.begin(), ::toupper);
                        if (upperSql.find("SELECT") == 0)
                        {
                            isQuery = true;
                        }

                        if (isQuery)
                        {
                            // 执行查询操作 - 使用OH_Rdb_ExecuteQueryV2
                            OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                            if (cursor == nullptr)
                            {
                                throw jsi::JSError(rt, "Failed to execute query: " + sql);
                            }

                            // 处理查询结果
                            jsi::Array resultArray = jsi::Array(rt, 0);
                            int rowIndex = 0;

                            while (cursor->goToNextRow(cursor) == RDB_OK)
                            {
                                int columnCount = 0;
                                if (cursor->getColumnCount(cursor, &columnCount) != RDB_OK)
                                {
                                    columnCount = 0;
                                }

                                jsi::Object rowObject(rt);

                                for (int i = 0; i < columnCount; i++)
                                {
                                    char columnName[256];
                                    if (cursor->getColumnName(cursor, i, columnName, sizeof(columnName)) == RDB_OK)
                                    {
                                        OH_ColumnType columnType;
                                        jsi::Value cellValue = jsi::Value::null();

                                        if (cursor->getColumnType(cursor, i, &columnType) == RDB_OK)
                                        {
                                            switch (columnType)
                                            {
                                            case 1: // TYPE_INT64
                                            {
                                                int64_t intValue;
                                                if (cursor->getInt64(cursor, i, &intValue) == RDB_OK)
                                                {
                                                    cellValue = jsi::Value(static_cast<double>(intValue));
                                                }
                                                break;
                                            }
                                            case 2: // TYPE_TEXT
                                            {
                                                char *textValue;
                                                int textLength = 0;
                                                if (cursor->getText(cursor, i, textValue, textLength) == RDB_OK)
                                                {
                                                    cellValue = jsi::String::createFromUtf8(rt, textValue);
                                                }
                                                break;
                                            }
                                            case 0: // TYPE_NULL
                                            {
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            case 4: // TYPE_BLOB
                                            {
                                                // BLOB类型暂不处理
                                                cellValue = jsi::Value::null();
                                                break;
                                            }
                                            }
                                        }

                                        rowObject.setProperty(rt, columnName, cellValue);
                                    }
                                }

                                resultArray.setValueAtIndex(rt, rowIndex, rowObject);
                                rowIndex++;
                            }

                            if (cursor != nullptr)
                            {
                                cursor->destroy(cursor);
                            }

                            DLOG(ERROR) << "123456789 unsafeQueryRaw查询完成 - 返回 " << rowIndex << " 行数据";
                            return resultArray;
                        }
                        else
                        {
                            // 执行非查询操作（INSERT/UPDATE/DELETE等）
                            int result = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                            if (result != RDB_OK)
                            {
                                throw jsi::JSError(rt, "Execute failed: " + sql + ", error: " + std::to_string(result));
                            }

                            DLOG(ERROR) << "123456789 unsafeQueryRaw非查询操作完成";
                            return jsi::Value::undefined();
                        }
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "unsafeQueryRaw failed: " + std::string(e.what()));
                    }
                });

            // 9. count方法
            auto countFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "count"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "count requires 2 arguments");
                    }

                    std::string sql = args[0].getString(rt).utf8(rt);
                    // jsi::Array arguments = args[1].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 count调用 - SQL: " << sql;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 执行COUNT查询
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            throw jsi::JSError(rt, "Failed to execute count query: " + sql);
                        }

                        int64_t countResult = 0;

                        // 移动到第一行
                        if (cursor->goToNextRow(cursor) == RDB_OK)
                        {
                            // 获取第一列的值（COUNT(*)的结果）
                            if (cursor->getInt64(cursor, 0, &countResult) != RDB_OK)
                            {
                                // 如果获取失败，记录错误并返回0
                                DLOG(ERROR) << "123456789 获取COUNT结果失败，返回0";
                                countResult = 0;
                            }
                        }

                        // 清理游标资源
                        if (cursor != nullptr)
                        {
                            cursor->destroy(cursor);
                        }

                        DLOG(ERROR) << "123456789 count完成 - 结果: " << countResult;

                        return jsi::Value(static_cast<double>(countResult));
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "count failed: " + std::string(e.what()));
                    }
                });

            // 10. batch方法
            auto batchFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "batch"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "batch requires 1 argument");
                    }

                    jsi::Array operations = args[0].getObject(rt).getArray(rt);

                    DLOG(ERROR) << "123456789 batch调用 - 操作数量: " << operations.size(rt);

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        OH_Rdb_Transaction *trans = nullptr;
                        OH_Rdb_BeginTransaction(globalStore);

                        // 执行批量操作
                        for (size_t i = 0; i < operations.size(rt); i++)
                        {
                            jsi::Value operationValue = operations.getValueAtIndex(rt, i);
                            if (operationValue.isObject())
                            {
                                jsi::Object operation = operationValue.getObject(rt);
                                std::string type = operation.getProperty(rt, "type").getString(rt).utf8(rt);

                                if (type == "execute")
                                {
                                    std::string sql = operation.getProperty(rt, "sql").getString(rt).utf8(rt);
                                    jsi::Array params = operation.getProperty(rt, "args").getObject(rt).getArray(rt);

                                    DLOG(ERROR) << "123456789 批量执行: " << sql;

                                    int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                    if (execResult != RDB_OK)
                                    {
                                        int rollbackResult = OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                                        if (rollbackResult != RDB_OK)
                                        {
                                            DLOG(ERROR) << "123456789 回滚事务失败";
                                        }

                                        throw jsi::JSError(rt, "Execute failed for SQL: " + sql);
                                    }
                                }
                            }
                        }

                        // 提交事务
                        OH_Rdb_Commit(globalStore);

                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "batch failed: " + std::string(e.what()));
                    }
                });

            // 11. batchJSON方法
            auto batchJSONFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "batchJSON"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "batchJSON requires 1 argument");
                    }

                    std::string operationsJson = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 batchJSON调用 - JSON长度: " << operationsJson.length();

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction, error code: " + std::to_string(beginResult));
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 简单的JSON解析实现
                            // 期望的JSON格式: [{"type":"execute","sql":"SQL语句","args":["参数1","参数2"]}]

                            // 检查是否是数组格式
                            if (operationsJson.empty() || operationsJson[0] != '[' || operationsJson[operationsJson.length() - 1] != ']')
                            {
                                throw std::runtime_error("Invalid JSON format - expected array");
                            }

                            // 移除方括号
                            std::string innerJson = operationsJson.substr(1, operationsJson.length() - 2);

                            // 分割操作对象
                            std::vector<std::string> operations;
                            size_t start = 0;
                            size_t braceCount = 0;
                            bool inQuotes = false;

                            for (size_t i = 0; i < innerJson.length(); i++)
                            {
                                char c = innerJson[i];
                                if (c == '\"' && (i == 0 || innerJson[i - 1] != '\\'))
                                {
                                    inQuotes = !inQuotes;
                                }
                                else if (!inQuotes)
                                {
                                    if (c == '{')
                                        braceCount++;
                                    else if (c == '}')
                                        braceCount--;

                                    if (c == ',' && braceCount == 0)
                                    {
                                        operations.push_back(innerJson.substr(start, i - start));
                                        start = i + 1;
                                    }
                                }
                            }

                            if (start < innerJson.length())
                            {
                                operations.push_back(innerJson.substr(start));
                            }

                            // 执行每个操作
                            for (const auto &operationStr : operations)
                            {
                                if (operationStr.empty())
                                    continue;

                                // 解析操作对象
                                std::string type;
                                std::string sql;
                                std::vector<std::string> args;

                                // 查找type字段
                                size_t typePos = operationStr.find("\"type\":");
                                if (typePos != std::string::npos)
                                {
                                    size_t startQuote = operationStr.find('\"', typePos + 7);
                                    size_t endQuote = operationStr.find('\"', startQuote + 1);
                                    if (startQuote != std::string::npos && endQuote != std::string::npos)
                                    {
                                        type = operationStr.substr(startQuote + 1, endQuote - startQuote - 1);
                                    }
                                }

                                // 查找sql字段
                                size_t sqlPos = operationStr.find("\"sql\":");
                                if (sqlPos != std::string::npos)
                                {
                                    size_t startQuote = operationStr.find('\"', sqlPos + 6);
                                    size_t endQuote = operationStr.find('\"', startQuote + 1);
                                    if (startQuote != std::string::npos && endQuote != std::string::npos)
                                    {
                                        sql = operationStr.substr(startQuote + 1, endQuote - startQuote - 1);
                                    }
                                }

                                // 新增：解析args参数数组
                                size_t argsPos = operationStr.find("\"args\":");
                                if (argsPos != std::string::npos)
                                {
                                    // 查找args数组的开始位置
                                    size_t arrayStart = operationStr.find('[', argsPos + 6);
                                    if (arrayStart != std::string::npos)
                                    {
                                        size_t arrayEnd = operationStr.find(']', arrayStart + 1);
                                        if (arrayEnd != std::string::npos)
                                        {
                                            std::string argsArray = operationStr.substr(arrayStart + 1, arrayEnd - arrayStart - 1);

                                            // 分割参数数组
                                            size_t paramStart = 0;
                                            bool inQuotes = false;
                                            for (size_t i = 0; i < argsArray.length(); i++)
                                            {
                                                char c = argsArray[i];
                                                if (c == '\"' && (i == 0 || argsArray[i - 1] != '\\'))
                                                {
                                                    inQuotes = !inQuotes;
                                                }
                                                else if (!inQuotes && c == ',')
                                                {
                                                    std::string param = argsArray.substr(paramStart, i - paramStart);
                                                    // 移除引号
                                                    if (param.length() >= 2 && param[0] == '\"' && param[param.length() - 1] == '\"')
                                                    {
                                                        param = param.substr(1, param.length() - 2);
                                                    }
                                                    args.push_back(param);
                                                    paramStart = i + 1;
                                                }
                                            }

                                            // 处理最后一个参数
                                            if (paramStart < argsArray.length())
                                            {
                                                std::string param = argsArray.substr(paramStart);
                                                if (param.length() >= 2 && param[0] == '\"' && param[param.length() - 1] == '\"')
                                                {
                                                    param = param.substr(1, param.length() - 2);
                                                }
                                                args.push_back(param);
                                            }
                                        }
                                    }
                                }

                                DLOG(ERROR) << "123456789 解析操作 - type: " << type << ", sql: " << sql << ", args数量: " << args.size();

                                if (type == "execute" && !sql.empty())
                                {

                                    int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                    if (execResult != RDB_OK)
                                    {
                                        success = false;
                                        errorMessage = "Execute failed for SQL: " + sql + ", error code: " + std::to_string(execResult);
                                        break;
                                    }
                                    DLOG(ERROR) << "123456789 SQL执行成功: " << sql;
                                }
                                else
                                {
                                    DLOG(ERROR) << "123456789 跳过不支持的操作类型: " << type;
                                }
                            }
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = e.what();
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_ExecuteV2(globalStore, "COMMIT", nullptr, nullptr);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                                throw jsi::JSError(rt, "Failed to commit transaction");
                            }
                            DLOG(ERROR) << "123456789 batchJSON完成 - 事务提交成功";
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "batchJSON failed: " + errorMessage);
                        }

                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_ExecuteV2(globalStore, "ROLLBACK", nullptr, nullptr);
                        throw jsi::JSError(rt, "batchJSON failed: " + std::string(e.what()));
                    }
                });

            // 12. getLocal方法
            auto getLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "getLocal"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "getLocal requires 1 argument");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 getLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 确保local_storage表存在
                        std::string createTableSql = "CREATE TABLE IF NOT EXISTS local_storage (key TEXT PRIMARY KEY, value TEXT)";
                        int createResult = OH_Rdb_ExecuteV2(globalStore, createTableSql.c_str(), nullptr, nullptr);
                        if (createResult != RDB_OK)
                        {
                            DLOG(ERROR) << "123456789 创建local_storage表失败: " << createResult;
                        }

                        // 使用字符串拼接的方式构建SQL（避免复杂的参数化查询）
                        std::string sql = "SELECT value FROM local_storage WHERE key = '" + key + "'";

                        // 执行查询 - 使用nullptr作为第二个参数
                        OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, sql.c_str(), nullptr);
                        if (cursor == nullptr)
                        {
                            DLOG(ERROR) << "123456789 查询失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 检查是否有结果
                        int rowCount = 0;
                        if (cursor->getRowCount(cursor, &rowCount) != RDB_OK)
                        {
                            rowCount = 0;
                        }

                        if (rowCount <= 0)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 未找到对应的值 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 移动到第一行
                        int moveResult = cursor->goToNextRow(cursor);
                        if (moveResult != RDB_OK)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 移动游标失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        // 获取值
                        char *value = nullptr;
                        int textLength = 0;
                        int getResult = cursor->getText(cursor, 0, value, textLength);
                        if (getResult != RDB_OK || value == nullptr)
                        {
                            cursor->destroy(cursor);
                            DLOG(ERROR) << "123456789 获取值失败 - 键: " << key;
                            return jsi::Value::null();
                        }

                        std::string resultValue = value;
                        cursor->destroy(cursor);

                        DLOG(ERROR) << "123456789 getLocal完成 - 键: " << key << ", 值: " << resultValue;
                        return jsi::String::createFromUtf8(rt, resultValue);
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "getLocal failed: " + std::string(e.what()));
                    }
                });

            // 13. unsafeLoadFromSync方法
            auto unsafeLoadFromSyncFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeLoadFromSync"),
                4,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 4)
                    {
                        throw jsi::JSError(rt, "unsafeLoadFromSync requires 4 arguments");
                    }

                    auto jsonId = (int)args[0].getNumber();
                    auto schema = args[1].getObject(rt);
                    std::string preamble = args[2].getString(rt).utf8(rt);
                    std::string postamble = args[3].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 unsafeLoadFromSync调用 - jsonId: " << jsonId;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for sync loading");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 1. 执行前导SQL（preamble）
                            if (!preamble.empty())
                            {
                                DLOG(ERROR) << "123456789 执行前导SQL: " << preamble;
                                int result = OH_Rdb_ExecuteV2(globalStore, preamble.c_str(), nullptr, nullptr);
                                if (result != RDB_OK)
                                {
                                    throw std::runtime_error("Failed to execute preamble SQL, error code: " + std::to_string(result));
                                }
                            }

                            // 2. 解析schema并创建临时表（如果需要）
                            // 这里需要根据schema参数创建对应的表结构
                            // 由于schema是jsi::Object，需要解析其结构
                            // 简化实现：假设schema已经存在，直接插入数据

                            // 3. 执行主要的同步数据插入逻辑
                            // 这里应该根据jsonId从某个地方获取同步数据
                            // 简化实现：记录日志并继续

                            DLOG(ERROR) << "123456789 处理同步数据 - jsonId: " << jsonId;

                            // 4. 执行后置SQL（postamble）
                            if (!postamble.empty())
                            {
                                DLOG(ERROR) << "123456789 执行后置SQL: " << postamble;
                                int result = OH_Rdb_ExecuteV2(globalStore, postamble.c_str(), nullptr, nullptr);
                                if (result != RDB_OK)
                                {
                                    throw std::runtime_error("Failed to execute postamble SQL, error code: " + std::to_string(result));
                                }
                            }

                            success = true;
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = e.what();
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for sync loading");
                            }
                            DLOG(ERROR) << "123456789 unsafeLoadFromSync完成";
                            return jsi::Value::null();
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "unsafeLoadFromSync failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "unsafeLoadFromSync failed: " + std::string(e.what()));
                    }
                });

            // 14. unsafeExecuteMultiple方法
            auto unsafeExecuteMultipleFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeExecuteMultiple"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "unsafeExecuteMultiple requires 1 argument");
                    }

                    auto sqlString = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 unsafeExecuteMultiple调用 - SQL长度: " << sqlString.length();

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for multiple SQL execution");
                        }

                        bool success = true;
                        std::string errorMessage;

                        try
                        {
                            // 按分号分隔SQL语句
                            std::vector<std::string> sqlStatements;
                            std::string currentStatement;
                            bool inQuotes = false;
                            char quoteChar = '\0';

                            for (size_t i = 0; i < sqlString.length(); i++)
                            {
                                char c = sqlString[i];

                                // 处理引号内的内容
                                if (c == '\'' || c == '\"')
                                {
                                    if (!inQuotes)
                                    {
                                        inQuotes = true;
                                        quoteChar = c;
                                    }
                                    else if (c == quoteChar)
                                    {
                                        inQuotes = false;
                                    }
                                }

                                // 不在引号内且遇到分号时，分隔语句
                                if (!inQuotes && c == ';')
                                {
                                    // 去除前后空白字符
                                    size_t start = currentStatement.find_first_not_of(" \t\n\r");
                                    size_t end = currentStatement.find_last_not_of(" \t\n\r");

                                    if (start != std::string::npos && end != std::string::npos)
                                    {
                                        std::string trimmed = currentStatement.substr(start, end - start + 1);
                                        if (!trimmed.empty())
                                        {
                                            sqlStatements.push_back(trimmed);
                                        }
                                    }
                                    currentStatement.clear();
                                }
                                else
                                {
                                    currentStatement += c;
                                }
                            }

                            // 处理最后一个语句（如果没有以分号结尾）
                            if (!currentStatement.empty())
                            {
                                size_t start = currentStatement.find_first_not_of(" \t\n\r");
                                size_t end = currentStatement.find_last_not_of(" \t\n\r");

                                if (start != std::string::npos && end != std::string::npos)
                                {
                                    std::string trimmed = currentStatement.substr(start, end - start + 1);
                                    if (!trimmed.empty())
                                    {
                                        sqlStatements.push_back(trimmed);
                                    }
                                }
                            }

                            DLOG(ERROR) << "123456789 解析出 " << sqlStatements.size() << " 个SQL语句";

                            // 逐个执行SQL语句
                            for (size_t i = 0; i < sqlStatements.size(); i++)
                            {
                                const auto &sql = sqlStatements[i];
                                DLOG(ERROR) << "123456789 正在执行第 " << (i + 1) << " 个SQL: " << sql;

                                int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);
                                if (execResult != RDB_OK)
                                {
                                    success = false;
                                    errorMessage = "Execute failed for SQL #" + std::to_string(i + 1) + ": " + sql + ", error code: " + std::to_string(execResult);
                                    break;
                                }
                            }
                        }
                        catch (const std::exception &e)
                        {
                            success = false;
                            errorMessage = "SQL parsing failed: " + std::string(e.what());
                        }

                        // 根据执行结果提交或回滚事务
                        if (success)
                        {
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                OH_Rdb_RollBack(globalStore);
                                throw jsi::JSError(rt, "Failed to commit transaction for multiple SQL execution");
                            }
                            DLOG(ERROR) << "123456789 unsafeExecuteMultiple完成 - 成功执行所有SQL语句";
                            return jsi::Value::undefined();
                        }
                        else
                        {
                            int rollbackResult = OH_Rdb_RollBack(globalStore);
                            if (rollbackResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 回滚事务失败";
                            }
                            throw jsi::JSError(rt, "unsafeExecuteMultiple failed: " + errorMessage);
                        }
                    }
                    catch (const std::exception &e)
                    {
                        // 确保在异常情况下回滚事务
                        OH_Rdb_RollBack(globalStore);
                        throw jsi::JSError(rt, "unsafeExecuteMultiple failed: " + std::string(e.what()));
                    }
                });

            // 15. setLocal方法
            auto setLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "setLocal"),
                2,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 2)
                    {
                        throw jsi::JSError(rt, "setLocal requires 2 arguments");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);
                    std::string value = args[1].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 setLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 插入或更新local_storage表
                        std::string sql = "INSERT OR REPLACE INTO local_storage (key, value) VALUES ('" + key + "', '" + value + "')";
                        int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                        if (execResult != RDB_OK)
                        {

                            throw jsi::JSError(rt, "setLocal failed with error code: " + std::to_string(execResult));
                        }

                        DLOG(ERROR) << "123456789 setLocal完成 - 键: " << key;
                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "setLocal failed: " + std::string(e.what()));
                    }
                });

            // 16. removeLocal方法
            auto removeLocalFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "removeLocal"),
                1,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    if (count < 1)
                    {
                        throw jsi::JSError(rt, "removeLocal requires 1 argument");
                    }

                    std::string key = args[0].getString(rt).utf8(rt);

                    DLOG(ERROR) << "123456789 removeLocal调用 - 键: " << key;

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 从local_storage表删除
                        std::string sql = "DELETE FROM local_storage WHERE key = '" + key + "'";
                        int execResult = OH_Rdb_ExecuteV2(globalStore, sql.c_str(), nullptr, nullptr);

                        if (execResult != RDB_OK)
                        {

                            throw jsi::JSError(rt, "removeLocal failed with error code: " + std::to_string(execResult));
                        }

                        DLOG(ERROR) << "123456789 removeLocal完成 - 键: " << key;
                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "removeLocal failed: " + std::string(e.what()));
                    }
                });

            // 17. unsafeResetDatabase方法
            auto unsafeResetDatabaseFunc = jsi::Function::createFromHostFunction(
                rt,
                jsi::PropNameID::forAscii(rt, "unsafeResetDatabase"),
                0,
                [](jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args, size_t count) -> jsi::Value
                {
                    DLOG(ERROR) << "123456789 unsafeResetDatabase调用 - 数据库重置";

                    try
                    {
                        std::lock_guard<std::mutex> lock(storeMutex);

                        // 检查数据库是否已初始化
                        if (!isDatabaseInitialized || globalStore == nullptr)
                        {
                            throw jsi::JSError(rt, "Database not initialized. Call initialize() first.");
                        }

                        // 开始事务
                        int beginResult = OH_Rdb_BeginTransaction(globalStore);
                        if (beginResult != RDB_OK)
                        {
                            throw jsi::JSError(rt, "Failed to begin transaction for database reset");
                        }

                        bool transactionSuccess = false;
                        try
                        {
                            // 方法1：动态获取所有用户表并删除（推荐）
                            // 查询sqlite_master获取所有用户表
                            std::string getTablesSql = "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'";
                            OH_Cursor *cursor = OH_Rdb_ExecuteQueryV2(globalStore, getTablesSql.c_str(), nullptr);

                            if (cursor != nullptr)
                            {
                                // 遍历所有表并删除
                                while (cursor->goToNextRow(cursor) == RDB_OK)
                                {
                                    char tableName[256];
                                    int nameLength = 0;
                                    // 修复：传递变量本身，而不是地址
                                    if (cursor->getText(cursor, 0, tableName, nameLength) == RDB_OK)
                                    {
                                        std::string table(tableName);
                                        if (table != "android_metadata") // 排除系统表
                                        {
                                            std::string dropSql = "DROP TABLE IF EXISTS " + table;
                                            int dropResult = OH_Rdb_ExecuteV2(globalStore, dropSql.c_str(), nullptr, nullptr);
                                            if (dropResult != RDB_OK)
                                            {
                                                DLOG(ERROR) << "123456789 删除表失败: " << table;
                                               
                                            }
                                            else
                                            {
                                                DLOG(ERROR) << "123456789 删除表: " << table;
                                            }
                                        }
                                    }
                                }
                                cursor->destroy(cursor);
                            }
                            else
                            {
                                // 方法2：如果无法查询表，使用预定义的表列表（备用方案）
                                std::vector<std::string> predefinedTables = {"local_storage", "sync_metadata", "changes", "movies"};
                                for (const auto &table : predefinedTables)
                                {
                                    std::string dropSql = "DROP TABLE IF EXISTS " + table;
                                    int dropResult = OH_Rdb_ExecuteV2(globalStore, dropSql.c_str(), nullptr, nullptr);
                                    if (dropResult != RDB_OK)
                                    {
                                        DLOG(ERROR) << "123456789 删除预定义表失败: " << table;
                                    }
                                    else
                                    {
                                        DLOG(ERROR) << "123456789 删除预定义表: " << table;
                                    }
                                }
                            }

                            // 清理WAL文件（如果支持）
                            // 执行VACUUM清理数据库空间
                            std::string vacuumSql = "VACUUM";
                            int vacuumResult = OH_Rdb_ExecuteV2(globalStore, vacuumSql.c_str(), nullptr, nullptr);
                            if (vacuumResult != RDB_OK)
                            {
                                DLOG(ERROR) << "123456789 VACUUM操作失败";
                            }

                            // 提交事务
                            int commitResult = OH_Rdb_Commit(globalStore);
                            if (commitResult != RDB_OK)
                            {
                                throw jsi::JSError(rt, "Failed to commit transaction for database reset");
                            }

                            transactionSuccess = true;
                            DLOG(ERROR) << "123456789 数据库重置完成";
                        }
                        catch (const std::exception &e)
                        {
                            // 回滚事务
                            OH_Rdb_RollBack(globalStore);
                            throw;
                        }

                        if (!transactionSuccess)
                        {
                            // 确保事务回滚
                            OH_Rdb_RollBack(globalStore);
                        }

                        return jsi::Value::undefined();
                    }
                    catch (const std::exception &e)
                    {
                        throw jsi::JSError(rt, "unsafeResetDatabase failed: " + std::string(e.what()));
                    }
                });

            // 将所有方法设置到适配器对象上
            adapter.setProperty(rt, "initialize", std::move(initializeFunc));
            adapter.setProperty(rt, "setUpWithSchema", std::move(setUpWithSchemaFunc));
            adapter.setProperty(rt, "setUpWithMigrations", std::move(setUpWithMigrationsFunc));
            adapter.setProperty(rt, "find", std::move(findFunc));
            adapter.setProperty(rt, "query", std::move(queryFunc));
            adapter.setProperty(rt, "queryAsArray", std::move(queryAsArrayFunc));
            adapter.setProperty(rt, "queryIds", std::move(queryIdsFunc));
            adapter.setProperty(rt, "unsafeQueryRaw", std::move(unsafeQueryRawFunc));
            adapter.setProperty(rt, "count", std::move(countFunc));
            adapter.setProperty(rt, "batch", std::move(batchFunc));
            adapter.setProperty(rt, "batchJSON", std::move(batchJSONFunc));
            adapter.setProperty(rt, "getLocal", std::move(getLocalFunc));
            adapter.setProperty(rt, "unsafeLoadFromSync", std::move(unsafeLoadFromSyncFunc));
            adapter.setProperty(rt, "unsafeExecuteMultiple", std::move(unsafeExecuteMultipleFunc));
            adapter.setProperty(rt, "setLocal", std::move(setLocalFunc));
            adapter.setProperty(rt, "removeLocal", std::move(removeLocalFunc));
            adapter.setProperty(rt, "unsafeResetDatabase", std::move(unsafeResetDatabaseFunc));

            return adapter;
        });

    globalObject.setProperty(rt, "nativeWatermelonCreateAdapter", std::move(createAdapterFunc));

    DLOG(ERROR) << "123456789 JSI初始化完成";
}